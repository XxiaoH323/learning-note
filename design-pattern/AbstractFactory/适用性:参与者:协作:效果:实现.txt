适用性
    1.一个系统要独立于它的产品的创建、组合和表示时
    2.一个系统要由多个产品系列总的一个来配置时
    3.当你要强调一系列相关的产品对象的设计以便进行联合使用时
    4.当你提供一个产品类库，而只想显示它们的接口而不是实现时

参与者--结合类图
    AbstractFactory - 声明一个创建抽象产品对象的操作接口
    ConcreteFactory - 实现创建具体产品对象的操作
    AbstractProduct - 为一类产品对象声明一个接口
    ConcreteProduct - 1.定义一个将被相应的具体工厂创建的产品对象 2.实现AbstractProduct接口
    Clinet - 仅使用由AbstractFactory和AbstractProduct类声明的接口

协作
    1.通常在运行时刻创建一个ConcreteFactory类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不用的工厂实现
    2.AbstractFactory将产品的创建延迟到它的ConcreteFactory子类

效果
    1.分离具体的类
    2.易于交换产品系列 -- 可以在运行时改变具体工厂实现
    3.有利于产品的一致性 -- 以窗口样式为例，相同样式的滑块、输入框才应该相互配合
    4.难以支持新种类产品 -- 增加一个产品，如增加一个选择器，那么就要在AbstractFactory定义一个创建选择器的抽象方法，那么它的所有子类都必须改写

实现
    1.具体工厂可以是一个单例
    2.创建产品
        a.AbstractFactory中为一系列产品的每种产品各自定义一个工厂方法 -- 缺点：每个系列的产品族都要有一个具体的ConcreteFactory类，即使不同系列的差别不大
        b.使用原型或Class这样的元类型，在实例化一个工厂时，初始化ConcreteFactory的每个产品域，实际创建时用原型或Class.getInstance这样的操作返回，
            这样可以不扩展子类，系列产品也可以随意配置
    3.定义可扩展的工厂
        AbstractFactory中不再为系列中的每个产品定义工厂方法，只定义一个create抽象方法，通过传参的方式，告知其需要创建该系列中的哪种产品
        缺点:
            这种方式要求，create方法返回的产品必须具有相同的抽象接口，同时客户将不能对产品进行区分或对一个产品的类型进行安全的假设。
            这样就会使得客户需要调用具体产品的操作时，需要进行不安全的向下转型，这是典型的高度灵活和可扩展接口的权衡折衷。