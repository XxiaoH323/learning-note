    该模式描述了如何建立一种一对多的依赖关系：关键对象是目标和观察者。一个目标可以有任意数目的依赖它的观察者。一单目标的状态改变，所有的观察者都得到通知。
作为对这个通知的响应，每个观察者都将查询目标以使其状态与目标的状态同步。
    主题是具有状态的对象，并且可以控制这些状态；被观察者（主题）具有状态太，而观察者使用这些状态，若干个观察者依赖主题来告诉他们状态何时改变了；
主体真正拥有状态，观察者依赖主题，在数据改变时，相比于各个对象控制同一份数据，这样可以得到更干净的OO设计
    主题和观察者是松耦合的。主题只知道观察者所实现的接口，但不知道其具体类型和任何实现细节；可以动态地增加和删除观察者而无需修改主题的任何代码，
主题只会发送通知给所有的观察者对象；只要两者的接口被遵循，就可以独立自由的改变具体实现


使用性
    1.当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这两种封装在独立的对象中以使它们可以独立地改变和复用
    2.当对一个对象的改变需要同步其他对象，而不知道具体有多少对象有待改变
    3.当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，你不希望这些对象是紧耦合的

参与者 -- 结合类图
    *** 类图中的备注信息只是一种提示，并非要按类图实现，具体实现问题可以参考下方内容 ***
    Subject（目标） - 目标知道观察者；可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口
    Observer（观察者） - 为那些在目标发生改变时需要得到通知的对象定义一个更新接口
    ConcreteSubject（具体目标） - 将有关状态存入各COncreteObserver对象；当它的状态改变时，向它的各个观察者发出通知
    ConcreteObserver（具体观察者） - 
        维护一个指向ConcreteSubject对象的引用 ---- 该对象可以用于查询目标状态、注册、去掉订阅等
        存储有关状态，这些状态应与目标的状态保持一致；
        实现Observer的更新接口以使自身状态与目标状态保持一致

协作 -- 结合时序图
    *** 目标对象状态的改变也是可以由观察者触发的，时序图就是这种情况（例子：表格和柱状图反映同一份数据，表格可以进行操作而改变数据具体数据） ***
    1.当ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者
    2.在得到一个具体目标的改变通知后，COncreteObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标的状态保持一致
    *** 注意事项 ***
        a.在《设计模式》中的例子，表格可以修改数据，所以时序图中的aConcreteObserver向aConcreteSubject发送一个数据更新通知也是可以的
        b.发出状态改变请求的aConcreteObserver并没有在发出信息时立即更新，而是等待aConcreteSubject的notify通知
            这和现在中给人的感觉可能不同，人为感觉在修改表格数据时，表格已经在动态的更新（update）
        c.nofify可以由模板对象本身，一个观察者（上述例子）或是其他对象调用（参见“实现第三点”）--- 其实“一个观察者”也是属于“其他对象调用”范畴


效果 - Observer模式允许独立的改变目标和观察者，可以单独复用目标对象而无需同时复用观察者，反之亦然；可以在不改动目标和其他观察者的前提下增加观察者
    1.目标和对象的抽象耦合 -- 同见上述第三段描述
        两者可以属于一个系统中的不同抽象层次：一个处于较低层次的目标对象可以与一个处于较高层次的观察者通信并通知它，做校验可以保持系统层次的完整
        如果两者混在一起，得到的对象那么横贯两个层次（违反层次性），要么放在两层见的某一层（可能会损害层次抽象）
    2.支持广播通信 - 目标对象不关心有多少对象对其感兴趣，它的唯一职责就是通知它的各个观察者，这样可以在任何时刻增加或删除观察者；处理还是忽略一个通知取决于观察者
    3.意外的更新 - 缺点
        a.一个观察者不知道另一个观察者存在，它可能对改变目标状态的最终代价一无所知。
            一个对目标对象看似无害的操作可能会引起一系列观察者以及依赖这些观察者的哪些对象的更新
        b.如果依赖准则的定义或维护不当，常常会引起哪一捕获的引起错误的更新
        c.简单的更新协议不提供具体细节说明目标中什么被改变了，如果没有其他的协议帮助观察者发现什么发生了改变，观察者可以会被迫尽力减少改变（观察者忽略通知）
            ** 可以参考“实现第七点” **

实现
    1.建立模板到其观察者之间的映射
        一个目标对象跟踪它应通知的观察者的最简单方式是显示地在目标中国保存对它们的引用
        然而，在目标很多而观察者很少时，这样存储可能代价太高（时因为C++中引用的存储开销大？每个目标可能引用同一个观察者？）
        空间换时间 --- 用一个关联查找机制（如hash表）来维护目标到观察者的映射，这样没有观察者的目标没有存储开销，但增加了访问观察者的开销
    2.观察多个目标
        某个观察者可能会观察多个目标，此时必须扩展update接口以使观察者知道哪一个目标发来的通知。
        目标对象可以简单的将自己作为update的参数让观察者知道去检查哪个目标
            a.观察者接口可能要定义一系列的update接口，在观察者调用时传入自身 --- 使得update的形参不能是最原始的Subject接口，而是“较为具体的子类型接口”
            b.在update方法中判断具体类型
    3.谁触发更新 - 由哪个对象调用notify来触发更新
        a.由目标对象的状态设定操作在改变目标对象的状态后自动调用notify
            优点：客户不需要记住在目标对象上调用notify
            缺点：多个连续的状态改变操作会产生多次连续的更新，可能会降低效率
        b.让客户负责在适当的时候调用notify
            优点：客户可以在一系列状态改变完成后在一次性触发更新，避免不必要的中间更新
            缺点：增加客户触发更新的责任，客户可能忘记调用notify
    4.对已删除对象的悬挂引用（可以查看相关资料了解“悬挂指针” - 百度百科解释：指针指向非法的内存地址，那么这个指针就是悬挂指针，意为无法正常使用的指针）
        **** Java有垃圾回收，没有此问题，但下述方式仍旧应该被采用，因为在Java中对象没有引用时才会被垃圾回收机制回收 ****
        删除一个目标时 应该注意不要让观察者中遗留对该目标的悬挂引用。一种避免方式是，当一个目标别删除时，让它通知它的观察者将对该目标的引用复位
        一般来说，不能简单的删除观察者，因为其他对象可能会引用它们，或者也可能它们还在观察其他的目标。（这里应该说的是，在删除目标时，不能级联删除该目标的观察者）
        ** 按“一般来说”的说法，目标也不能随便删除，因为无法知道哪里存在对目标的引用，但在Java中无需关心，
            因为Java没有指针，在某处“切断”对目标的引用，并不会影响其他引用该对象的地方，因为目标还未被回收 **
    5.在发出通知前确目标的状态自身是一致的，因为观察者在更新自身状态的过程中需要查询目标的当前状态
        在Subject的子类调用继承的notify操作时，旺旺会返回这一“状态自身一致”准则，例如subSubject先通知观察者再更新状态
        此时，可以在Subject中定义模板方法，在模板的末尾调用notify ---- 这样将notify定义成private较为合理，这样客户就没有机会调用notify，参见第三点
    6.避免特定于观察者的更新协议——推/拉模型
        *** 这里小标题有所歧义 ***
        观察者模式的实现需要让目标广播关于其改变的其他一些信息。目标将这些信息作为update的参数传递给观察者，这些信息可大可小。
        a.一个极端是“推模型”，目标向观察者发送关于改变的详细信息，而不管观察者需要与否，假定目标知道一些观察者的需要的信息；
            该模型使得观察者相对难以复用，因为目标对观察者的假设可能并不总是正确的
        b.另一个极端是“拉模型”，目标除最小通知外什么也不发出，而此后由观察者显示地向目标询问细节，强调目标不知道它的观察者。
            该模式的效率较差，因为观察者对象需要在没有目标的帮助下确定什么改变了
    7.显示地指定感兴趣的改变 - 控制目标的注册接口，让各个观察者注册为仅对特定时间感兴趣，以提高更新效率  
        -- 这一点和第二点不同，第二点强调的是“一个观察者观察多个目标”
        可以定义以下接口来达到这样的目的(C++)
            Subject中定义“void Subject::Attach(Observer*, Aspect& interest);”
            Observer中定义“void Observer::Update(Subject*, Aspect& interest);”
        这里可以有两种实现
            a.在Subject改用Map<Aspect, List<Observer>>这样的类型，在Attach方法上做判断放入对应的List中，在需要通知观察者时取相应的List
            b.在Subject仍旧单一的使用List<Observer>，而具体的Observer在update方法中过滤掉自己不关心的通知
    8.封装复杂的更新语义
        当目标和观察者的依赖关系特别复杂时，可能需要一个维护这些关系的对象，即“更改管理器（ChangeManager）” -- 参考“更改管理器类图”
        ChangeManager职责：
            a.将一个目标映射到它的观察者并提供一个接口来维护这个映射，从而不需要由目标来维护其观察者的应用，反之亦然
                （观察者、观察目标的依赖关系委托给ChangeManager维护，那可以不必有相互引用）
            b.它定义一个特定的更新策略
            c.根据一个目标的请求，它更新所有依赖于这个目标的观察者
        类图描述：SimpleChangeManager总是更新每一个目标的所有观察者；DAGChangeManager处理目标及其观察者之间的依赖关系构成的无环有向图。
            当一个观察者观察过个目标时，此时两个或更多的目标中产生的改变可能会产生冗余的更新，DAGChangeManager确保观察者仅接受一个更新。
            根据图中的实现，Obserer没有ChangeManager的引用，和"中介者"有一定差异，此类图中Observer向Subject注册时，Subject将依赖关系委托给ChangeManager，
            而Subject发出通知时，也是委托给ChangeManager转发，而CHangeManager会有具体实现来达到不同的目的  ---> 此处和“反之亦然”有所不同
        *** ChangeManager是一个中介者，也可以被实现为单例 ***
    9.结合目标类和观察者，此时一个对象可以既是观察者也是目标。SmallTalk中，Subject和Observer接口定义于根类Object，使得所有类都可以使用观察者模式
        但这种方式在“效果第一点”中提到了可能存在的问题

观察者模式怎么符合OO原则
    1.封装变化
        该模式中会改变的是主题的状态以及观察者的数量和类型，其可以改变依赖于主题状态的对象，却不必改变主题
    2.针对接口而非实现编程
        主题与观察者都用接口：观察者向利用主题的接口注册，而主题利用观察者接口通知观察者
    3.多用组合，少用继承
        利用“组合”将很多观察者组合进主题中，这种关系不是通过继承实现的，而是在运行时利用组合的方式产生的

Java内置的观察者模式
    1.主题继承（extend）Observable，而观察者实现（implement）Observer
        a.在Observable类中定义了注册，取消订阅，通知（notify）等接口
        b.在通知观察者时，需要先调用setChange方法，否则观察者不会得到通知
            setChange方法可以在更新观察者时更具弹性，可以在更加适合的时候通知观察者（《Head First》中的气象站例子，可以避免十分微弱的信息变化造成布告板的更新）
            *** 可以结合“实现第三点.b”思考 ***  
        c.Observablele类提供notifyObservers()和notifyObservers(Object arg)来发出通知，
            而Observer接口中有一个更新方法为update(Observable o, Object arg) --- 推/拉模型
        d.*** 问题，违反“少用继承，多用组合”的原则 ***
            一、Observable是一个类，无法建立自己的实现来和Java内置的Observer API搭配使用
                理解：
                    “无法建立自己的实现”，实现是对接口的实现（设计模式中通用的概念），而此方式要求的是继承（即使可以重写父类方法）
                    “搭配使用”，因为update的第一个参数就是Observable，这就要求Observer只能和Observable搭配
            二、setChange()的访问权限是protected的，而该方法又必须在通知观察者前调用，这就要求必须使用继承
                原因：protected访问权限只有子类和当前包可到，这就要求外部系统在使用是必须继承Observable，从而修改setChange()的访问权限为public，
                    这样才能被使用
    2.Swing编程中，组件的事件监听器 --- 监听器是观察者，而主题则是组件，主题在改变状态时（如单击），对应的事件监听器会进行处理