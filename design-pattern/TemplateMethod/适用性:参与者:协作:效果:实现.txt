适用性
    1.一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
    2.各子类中公共的行为被提取出来并集中到一个公共的父类中以避免代码重复
    首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码（《Head First》中的咖啡因饮料就是如此）
    3.控制子类的扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展

参与者 -- 结合类图
    AbstractClass(抽象类) 
        - 定义抽象的原语操作(primitive operation)，具体的子类将重定义它们以实现一个算法的各步骤
        - 实现一个模板方法，定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作
    ConcreteClass(具体类) - 实现原语操作以完成算法中与特定子类相关的步骤

协作
    ConcreteClass靠AbstractClass来实现算法中不变的步骤

效果
    1.模板方法是一种代码复用的基本技术。导致一种反向的控制结构（好莱坞法则-即“别找我们，我们找你”）。这指的是一个父类调用一个子类的操作，而不是相反
    2.模板方法调用如下操作：
        a.具体的操作
        b.具体的AbstractClass的操作（即，通常对子类有用的操作）
        c.原语操作
        d.Factory Method
        e.钩子操作(hook operations)，其提供缺省实现，子类可以在必要时进行扩展
    3.模板方法应指明哪些操作是钩子操作（可以被重定义）以及哪些是抽象操作（必须被重定义）。

实现
    1.访问权限-最理想的原语操作的访问权限是，在模仿方法中可用，且能被子类重定义
        a.在C++中，受保护方法可以达到这样的效果
        b.在Java中，protected没有C++的严格(《核心技术卷1》有提到)，因为protected修饰的实例域和方法除了在子类中可见外，同一包下的不相关类也能访问
            在Java中，可以将模板方法定义为final，避免子类重写算法流程，将原语操作定义为protected访问权限的抽象方法，
        而模板方法所在类也就必须是Abstract的(无法实例化)，这样protected权限就可以避免同包访问
    2.尽量减少源于操作。定义模板方法的一个重要目的是尽量减少一个子类具体实现该算法时必须重定义的那些原语操作的数目。原语操作越多，客户程序就越冗长。
        《Head First》P295-可以让算法步骤不要切割得太细，但如果过少，就没有弹性，所以需要折衷。
            **注意**某些操作如果是可选的，可以将这些步骤定义为hook，而不是通过实现抽象方法，注意可以让抽象类的子类的负担减轻。
    3.命名约定。

模板方法的应用
    1.Java中Arrays工具类的sort方法 - 该方法要求待排序的对象需要实现Comparable接口
        a.模板方法的重点在于提供一个算法，让子类实现某些步骤；虽然sort方法的实现并非如此，但其符合模范方法的精神，
            在sort中已经定义了排序的算法流程（冒泡、选择等，anyway），但数组中元素如果比较则有元素本身决定
        b.之所以这一方法归为模板方法，而非策略模式（这里看起来像是用Arrays来排序某个数组对象，策略就是客户类用策略来达到某一目的），原因在于：
            策略模式中所组合的类实现了整个算法（策略作为客户类的一个实例域），而Arrays所提供的算法并不完成，它需要一个类填补如何比较这一实现
    2.Swing中的JFrame
        a.有一个update方法，该方法会调用print操作：update可看成是一个模板方法，虽然print并不是原语操作，有默认实现
        b.其实update和print方法是在JFrame的父类Component中定义的
    3.Applet - 它有一些init，start等一些钩子操作，会在网页进行加载、跳转或浏览器关闭时被调用，可以理解Applet为网页工作定义了模板，而钩子则被用于自定义
    4.Spring - Spring Bean在被创建、被销毁时会有和3类似的操作

***钩子操作（hook）***
    钩子操作有很多用法：
    1.在《Head First》中，使hook来判断是否需要在泡完咖啡因饮料时加入调味品(糖、奶精等) --- hook默认返回true，子类重写用标准输入询问
    2.在《设计模式-可复用面向对象软件的基础》中，说到一种情况：在扩展父类的操作时，可以在子类中重写该方法，但在开始首先调用父类实现，这样来达到扩展而非仅是重写的目的，
    但是父类实现的调用往往会被忘记，这样可以如下方式解决：在父类的可被扩展的实现末尾加入一个空实现的hook，子类重定义hook，而不再重定义需被扩展的方法(在Java中用final修饰更有效)
    3.上面应用中的第三和第四种